연산자

1. 연산자와 연산식

	- 연산(operations) : 데이터를 처리하여 결과를 산출하는 것
		연산자(operator) : 연산에 사용되는 표시나 기호
		피연산자(operand) : 연산되는 데이터
	
	- 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것을 연산식(expressions)이라고 함
	
	- 연산자
	
		연산자 종류		연산자				피연산자의 수	산출값			기능 설명
	------------------------------------------------------------------------------------------
		산술			+,-,*,/,%			이항			숫자				사칙연산 및 나머지 계산
		부호			+,-					단항			숫자				음수와 양수의 부호
		문자열		+					이항			문자열			두 문자열을 연결
		대입			=,+=,-=,*=,/=,		이항			다양				우변의 값을 좌변의 변수에 대입
					%=,^=,|=,<<=,
					>>=,>>>=		
		증감			++,--				단항			숫자				1만큼 증가/감소
		비교			==,!=,>,<,>=,		이항			boolean			값의 비교
					<=,instanceof
		논리			!,&,|,&&,||			단항, 이항		boolean			논리적 NOT, AND, OR 연산
		조건			(조건식)?A:B			삼항			다양				조건식에 따라 A 또는 B 중 하나를 선택
		비트			~,&,|,^				단항, 이항		숫자, boolean		비트 NOT, AND, OR, XOR 연산
		쉬프트		>>,<<,>>>		이항				숫자				비트를 좌측/우측으로 밀어서 이동
		
2. 연산의 방향과 우선순위

	- 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있음
		1) 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
		2) 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다
		3) 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다.
		4) 복잡한 연산식에는 괄호()를 사용해서 우선순위를 정해준다.
		
3. 단항 연산자

	3.1 부호 연산자(+, -)
	
		- 양수 및 음수를 표시
		- 부호 연산자의 산출 타입은 int 타입이 됨
		
	3.2 증감 연산자(++, --)
		
		- 변수의 값을 1 증가시키거나(++) 감소시키는(--) 연산자를 말함
		- 피연산자의 앞에 붙느냐 뒤에 붙느냐에 따라 의미가 달라짐
			앞 : 다른 연산을 수행하기 전에 피연산자의 값을 변화시킴
			뒤 : 다른 연산을 수행한 후에 피연산자의 값을 변화시킴
			
		- ++i와 i=i+1은 동일한 바이트 코드로 컴파일 되므로 연산 속도는 같음
		
	3.3 논리 부정 연산자(!)
	
		- true를 false로, false를 true로 변경
		
	3.4 비트 반전 연산자(~)
	
		- 피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전함
		- 부호 비트인 최상위 비트를 포함해서 반전되므로 부호가 반대인 값이 산출됨
		- 비트 반전 연산자의 산출 타입은 int 타입
	
4. 이항 연산자

	- 피연산자가 두 개인 연산자
	
	4.1 산술 연산자(+, -, *, /, %)
	
		- 더하기, 빼기, 곱하기, 나누기, 나머지 연산
		- 기본적으로 정수 타입 연산은 int로 결과가 나옴
			char 간 연산도 int로 나오게 되므로 (char)로 캐스팅 해주어야 문자를 얻을 수 있음
			
		- 오버플로우 탐지
			연산 후의 산출값이 산출 타입으로 표현 가능한지 확인해야 함(쓰레기값을 피하기 위함)
		
		- 정확한 계산은 정수 사용
			정확한 연산이 필요할 때는 부동소수점 타입을 사용하지 않는 것이 좋음
			
		- NaN과 Infinity 연산
			/ 또는 % 연산자를 사용할 때 나누는 수는 0을 사용할 수 없음
			
			5 / 0		- 컴파일은 정상적으로 되지만 실행 시 ArithmeticException(예외) 발생
			5 % 0		- 컴파일은 정상적으로 되지만 실행 시 ArithmeticException(예외) 발생
			
			실수 타입인 0.0 또는 0.0f 로 나누면 예외가 발생하지 않고, Infinity(무한대) 값과 NaN(Not a Number) 값을 가짐
			
			5 / 0.0		- Infinity
			5 % 0.0		- NaN
			
			Infinity 나 NaN이 나오면 어떤 수와 연산하더라도 Infinity와 NaN이 산출되어 데이터가 엉망이 됨
				Double.isInfinite() 와 Double.isNaN() 메소드를 이용하여 처리(true, false 로 값이 산출)
				
		- 입력값의 NaN 검사
			부동소수점을 입력받을 때는 반드시 NaN 검사를 해야함
			입력값이 NaN인지 확인하여 NaN일 때는 연산이 수행되지 않도록 처리
			
	4.2 문자열 연결 연산자(+)
	
		- 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용
		
	4.3 비교 연산자(<,<=,>,>=,==,!=)
		
		- 대소 또는 동등 비교를 통해 boolean 값을 산출
			char 타입의 경우 유니코드 값으로 비교 연산 수행
			float과 double의 경우 근사값 표현 범위 차이로 인해 동등 비교할 시 강제 타입 변환이 필요
			
		- String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없고, 동등 비교 연산자는 사용 가능
			문자열이 같은지, 다른지를 비교하는 용도로는 사용되지 않음
			String은 참조 타입으로 객체 주소 참조를 통한 비교를 하므로 같은 문자열이어도 주소에 따라 다르게 인식됨
			따라서 String 타입의 문자열 자체만 비교하고 싶다면 equals() 메소드를 사용해야 함
			
	4.4 논리 연산자(&&, ||, &, |, ^, !)
	
		- AND : 논리곱(&&, &) 
			피연산자 모두가 true일 경우에만 연산 결과 true
		
		- OR : 논리합(||, |)
			피연산자 중 하나만 true이면 연산 결과는 true
			
		- XOR : 배타적논리합(^)
			피연산자가 하나는 true이고 다른 하나가 false일 경우에만 연산 결과는 true
			
		- NOT : 논리부정(!)
			피연산자의 논리값을 바꿈
			
	4.5 비트 연산자(&, |, ^, ~, <<, >>, >>>)
	
		- 데이터를 비트 단위로 연산
			비트 논리 연산 : 0과 1에 대한 논리 연산(논리 연산자와 동일하게 작동)
			비트 이동 연산 : 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산 
			
	4.6 대입 연산자
	
		- 오른쪽 피연산자의 값을 왼쪽 피연산자인 변수에 저장
		
5. 삼항 연산자

	- 세 개의 피연산자를 필요로 하는 연산자
	- 조건식 ? 참 : 거짓 
	
----------------------------------------------------------------------------------------------------------------------------------------

확인 문제

1. 연산자와 연산식에 대한 설명 중 틀린 것은 무엇인가?

	1) 연산자는 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 구분된다.
	2) 비교 연산자와 논리 연산자의 산출 타입은 boolean(true/false)이다.
	3) 연산식은 하나 이상의 값을 산출할 수도 있다.
	4) 하나의 값이 올 수 있는 자리라면 연산식도 올 수 있다.

2. 다음 코드를 실행했을 때 출력 결과는 무엇입니까?

	Exercise02.java
	--------------------------------------------
	public class Exercise02 {
		public static void main(String[] args) {
			int x = 10;
			int y = 20;
			int z = (++x) + (y--);
			System.out.println(z);
		}
	}
	
3. 다음 코드를 실행했을 때 출력 결과는 무엇입니까?
   
	Exercise03.java
	--------------------------------------------
	public class Exercise03 {
		public static void main(String[] args) {
			int score = 85;
			String result = (!(score>90))? "가" : "나";
			System.out.println(result);
		}
	}
	

4. 534자루의 연필을 30명의 학생들에게 똑같은 개수로 나누어 줄 때 학생당 몇 개를 가질 수 있고, 최종적으로 몇 개가 남는지를 구하는 코드입니다.
   ( #1 )과 ( #2 )에 들어갈 알맞은 코드를 작성하세요.

   	Exercise04.java
	--------------------------------------------
	public class Exercise04 {
		public static void main(String[] args) {
			int pencils = 534;
			int students = 30;
			
			//학생 한 명이 가지는 연필 수
			int pencilsPerStudent = ( #1 );
			System.out.println(pencilsPerStudent);
			
			//남은 연필 수
			int pencilsLeft = ( #2 );
			System.out.println(pencilLeft);
		}
	}
   
5. 다음은 십의 자리 이하를 버리는 코드입니다. 변수 value의 값이 356이라면 300이 나올 수 있도록 ( #1 )에 알맞은 코드를 작성하세요(산술 연산자만 사용하세요)

   	Exercise05.java
	--------------------------------------------
	public class Exercise05 {
		public static void main(String[] args) {
			int value = 356;
			System.out.println( #1 );
		}
	}

6. 다음 코드는 사다리꼴의 넓이를 구하는 코드입니다. 정확히 소수자릿수가 나올 수 있도록 ( #1 )에 알맞은 코드를 작성하세요.

   	Exercise06.java
	--------------------------------------------
	public class Exercise06 {
		public static void main(String[] args) {
			int lengthTop = 5;
			int lengthBottom = 10;
			int height = 7;
			double area = ( #1 );
			System.out.println(area);
		}
	}

7. 다음 코드는 비교 연산자와 논리 연산자의 복합 연산식입니다. 연산식의 출력 결과를 괄호() 속에 넣으세요.

   	Exercise07.java
	--------------------------------------------
	public class Exercise07 {
		public static void main(String[] args) {
			int x = 10;
			int y = 5;
			
			System.out.println( (x>7) && (y<=5) );				----(		)
			System.out.println( (x%3 == 2) || (y%2 != 1) );		----(		)
		}
	}

8. 다음은 %연산을 수행한 결과값에 10을 더하는 코드입니다. NaN 값을 검사해서 올바른 결과가 출력될 수 있도록 ( #1 )에 들어갈 NaN을 검사하는 코드를 작성하세요.

   	Exercise08.java
	--------------------------------------------
	public class Exercise08 {
		public static void main(String[] args) {
			double x = 5.0;
			double y = 0.0;
			
			double z = x % y;
			
			if( #1 ) {
				System.out.println("0.0으로 나눌 수 없습니다.")
			} else {
				double result = z + 10;
				System.out.println("결과 : " + result);
			}
		}
	}

----------------------------------------------------------------------------------------------------------------------------------------

확인 문제 정답

1. 3)
2. 31
3. 가
4.	#1 : pencils / student
	#2 : pencils % student
5. value/100*100
6. 	#1 : (lenghtTop + lengthBottom) * height / 2.0
7. true, false
8. 	#1 : Double.isNaN(z)